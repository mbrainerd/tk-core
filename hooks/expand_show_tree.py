"""
This hook is called when an engine, app or framework calls 

> self.expand_show_tree(user_subdir_list, show_subdir_list, path)

Typically apps, engines and frameworks call this method
when they want to map the given path on a show tree.
The default implementation expands this path on the basis of the context of ``bundle_obj``
And will construct an inheritance model as per the order shown below.

Entries in the lookup path are arranged so the inheritance is as follows:

    - show
    - show-work-area
    - sequence
    - sequence-work-area
    - shot
    - shot-work-area

At each level, hook paths are searched for in the following order:

    - <filename>
    - <filename>_<role>
    - <filename>_<role>_<subrole>
    - <site>/<filename>
    - <site>/<filename>_<role>
    - <site>/<filename>_<role>_<subrole>

This would typically not need to be customized.

In case customization is required, the hook is passed the app/engine/framework
that issued the original request - this gives access to configuration,
app methods, environment etc. and should allow for some sophisticated
introspection inside the hook.
"""

import os

import sgtk
from sgtk import dd_xplatform_utils

HookBaseClass = sgtk.get_hook_baseclass()


class ExpandShowTree(HookBaseClass):
    
    def execute(self, path, bundle_obj, role=None, location=os.getenv("DD_LOCATION", ""), user_subdir="etc",
                show_subdir="SHARED/etc", extra_subdir="sgtk/hooks", **kwargs):
        """
        Handle expansion of the given path on show tree, depending on context issued from an app, framework or engine.
        
        :param path: path to create
        :param bundle_obj: object requesting the creation. This is a legacy
                              parameter and we recommend using self.parent instead.
        :param role: Role at which the hook should be resolved for, by default it tries to pick up the step from context
                    if Step is not there, then it tries to resolved using $DD_ROLE.
        :param location: Location at which the hook should be resolved for, adds <site> after of the extra_subdir.
                by default it picks up from $DD_LOCATION
        :param user_subdir: Subdirectories to use for resolving work-area hooks, can be colon separated.
        :param show_subdir: Subdirectories to use for resolving show-tree hooks, can be colon separated.
        :param extra_subdir: additional subdirectories to be included in the hierarchy, CAN'T be colon separated.

        :return: A colon separated list of paths in the order of Test_User:Shot:Seq:Project,
        code that calls it can decide what to do with that paths.
        """

        user_subdir_list = user_subdir.split(os.pathsep)
        show_subdir_list = show_subdir.split(os.pathsep)

        # add the extra subdir to the search path
        if extra_subdir:
            user_subdir_list = [os.path.join(x, extra_subdir) for x in user_subdir_list]
            show_subdir_list = [os.path.join(x, extra_subdir) for x in show_subdir_list]

        default_root = bundle_obj.tank.pipeline_configuration.get_primary_data_root()
        # this is (:) separated list of paths
        show_paths = self.expand_tree(bundle_obj.context, default_root, role, location,
                                      user_subdir_list, show_subdir_list, path)

        # return colon separated list of paths, to keep the inheritance model intact.
        return show_paths

        # we need to return the first path since that is the override we have configured
        # Seq:Shot:Project
        # if paths_list:
        #     return paths_list[0]

        # none of the paths exist! the hook was configured without actually populating the show with the hook.
        # return ''

    @staticmethod
    def expand_tree(context, default_root, role, location, user_subdir_list, show_subdir_list, path):
        """Iterate over the standard lookup path and build the inheritance model for the hooks.

        In order, hook path will be resolved from top to bottom and accumulated
        as they are collected. In other words the inheritance model will
        follow the hierarchy that's shown below.

        Entries in the lookup path are arranged so the inheritance is as follows:

            - show
            - show-work-area
            - sequence
            - sequence-work-area
            - shot
            - shot-work-area

        At each level, hook paths are searched for in the following order:

            - <filename>
            - <filename>_<role>
            - <filename>_<role>_<subrole>
            - <site>/<filename>
            - <site>/<filename>_<role>
            - <site>/<filename>_<role>_<subrole>


        The generated platform-dependent path is returned with
        variables expanded to values contained in this instance.
        The returned path is generated by invoking :meth:`sgtk.dd_xplatform_utils.build_path`.

        """
        paths = [path]

        # if user didn't provide any role, try to resolve it from the context.
        if not role:
            if context.step:
                role = context.step.get("name", "")
            else:
                role = os.getenv("DD_ROLE", "")

        # construct role specific file paths
        if role:
            sub_roles = role.split("_")
            base_name, extension = os.path.splitext(path)

            role_suffix = ""
            for sub_role in sub_roles:
                role_suffix = role_suffix + "_" + sub_role
                paths.append("%s%s%s" % (base_name, role_suffix, extension))

        # add site specific paths to the mix as well
        if location:
            user_subdir_list.extend([os.path.join(x, location) for x in user_subdir_list])
            show_subdir_list.extend([os.path.join(x, location) for x in show_subdir_list])

        if context.project is None:
            # our context is completely empty!
            # there is no show tree to expand these paths on
            return ''

        prefixes = []
        if context.entity is None:
            # add show paths to the mix
            prefixes.extend([
                default_root,
            ])

        if context.entity:
            # we have an entity

            if context.entity["type"] == "Sequence":
                # add the sequence paths to the mix
                prefixes.extend([
                    default_root,
                    os.path.join(default_root, context.entity["name"]),
                ])

            if context.entity["type"] == "Shot":
                entities_by_type = dict([(x["type"], x) for x in context.additional_entities])
                seq_entity = entities_by_type["Sequence"]
                # add the sequence and shot paths to the mix
                prefixes.extend([
                    default_root,
                    os.path.join(default_root, seq_entity["name"]),
                    os.path.join(default_root, seq_entity["name"], context.entity["name"]),
                ])

            # since there is no quicker way to get an asset level
            # Let's add support for an Asset entity with show:seq:shot:user
            if context.entity["type"] == "Asset":
                entities_by_type = dict([(x["type"], x) for x in context.additional_entities])
                # add show paths to the mix
                prefixes.extend([
                    default_root,
                ])
                # add the sequence paths to the mix
                seq_entity = entities_by_type.get("Sequence")
                if seq_entity:
                    prefixes.append(os.path.join(default_root, seq_entity["name"]))
                # add the sequence and shot paths to the mix
                shot_entity = entities_by_type.get("Shot")
                if shot_entity and seq_entity:
                    prefixes.append(os.path.join(default_root, seq_entity["name"], shot_entity["name"]))

        branch_paths = show_subdir_list

        if os.environ.get("DD_TEST_BRANCHES") == "user" and os.environ.get("DD_WORKAREA"):
            branch_paths.extend([os.path.join("user/work.$DD_WORKAREA", x) for x in user_subdir_list])
        elif os.environ.get("DD_TEST_BRANCHES") == "user" and not os.environ.get("DD_WORKAREA"):
            branch_paths.extend([os.path.join("user/work.$USER", x) for x in user_subdir_list])

        # this only returns us the paths that actually exist, hence enabling us to follow this search path pattern
        return dd_xplatform_utils.build_path(*dd_xplatform_utils.combine_paths(prefixes, branch_paths, paths))
